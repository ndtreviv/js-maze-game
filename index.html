<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maze Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Rock+Salt&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;

            user-select: none;
            -webkit-user-select: none;
            /* Safari */
            -ms-user-select: none;
            /* IE 10 and IE 11 */
        }

        body,
        html {
            width: 100%;
            height: 100%;
            font-family: sans-serif;
            background: beige;
            overflow: hidden;
        }

        #background {
            position: absolute;
            width: 100%;
            height: 100%;
            background-image: url('assets/background.png');
            background-size: cover;
            background-position: center;
        }

        #screen-start,
        #screen-name,
        #screen-game,
        #screen-complete,
        #screen-times {
            position: absolute;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .visible {
            display: flex !important;
        }

        button {
            background-color: green;
            color: white;
            padding: 1em 2em;
            border: none;
            border-radius: 10px;
            font-size: 1.2em;
            cursor: pointer;
        }

        #mazeCanvas {
            background: beige;
            display: block;
            border: 10px solid black;
            width: 100vw;
            height: 100vh;
        }

        #coinCount {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 1.5em;
            color: black;
            background: white;
            padding: 0.5em 1em;
            border-radius: 10px;
        }

        .red-btn {
            background-color: red;
            margin-top: 20px;
        }

        /* Ensure canvas resizes smoothly */
        canvas {
            max-width: 100%;
            height: auto;
        }

        /* Responsive controls and scaling for small screens */
        @media (max-width: 600px) {
            button {
                font-size: 1em;
                padding: 0.7em 1.5em;
            }

            #mazeCanvas {
                width: 100vw;
                height: 100vh;
            }

            #coinCount {
                font-size: 1.2em;
                padding: 0.4em 0.8em;
            }

            .control-btn {
                width: 50px;
                height: 50px;
                font-size: 24px;
            }

            #controls {
                bottom: 10px;
                left: 10px;
                gap: 5px;
                grid-template-columns: 50px 50px 50px;
                grid-template-rows: 50px 50px;
            }
        }
    </style>
    <style>
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px;
            gap: 10px;
            z-index: 10;
        }

        .control-btn {
            width: 60px;
            height: 60px;
            font-size: 30px;
            font-weight: bold;
            border-radius: 10px;
            background: white;
            color: black;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            border: 2px solid black;
            user-select: none;
            -webkit-user-select: none;
            /* Safari */
            -ms-user-select: none;
            /* IE 10 and IE 11 */
        }

        .control-btn:active {
            background: #ddd;
        }


        #gameTitle {
            font-family: 'Rock Salt', cursive;
            font-size: 2em;
            color: #fff;
            width: 100%;
            text-align: center;
            margin-top: 0.5em;
            text-shadow: 3px 3px 0 #000, -3px -3px 0 #000;
            animation: pulse 2s ease-in-out infinite;
            margin-bottom: 1em;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        .hidden {
            display: none;
        }
    </style>
</head>

<body>
    <div id="background"></div>
    <div id="screen-start" class="visible">
        <img id="gameTitle" src="assets/mazegametitle.treviv.png" alt="Maze Game Title"
            style="width: 80%; max-width: 600px; animation: pulse 2s ease-in-out infinite; margin-bottom: 1em;" />
        <img id="btnStart1" src="assets/start.png" alt="Start Game"
            style="width: 200px; cursor: pointer; margin-bottom: 10px;" />
        <button id="btnShowTimes">Times</button>
    </div>
    <div id="screen-name">
        <input id="nameInput" placeholder="Enter your name" />
        <button id="btnStart2">Start Maze</button>
    </div>
    <div id="screen-game">
        <canvas id="mazeCanvas"></canvas>
        <div id="coinCount">🪙 0</div>
        <div id="shop-screen" class="hidden"
            style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(240, 220, 180, 0.95); display: none; flex-direction: column; align-items: center; justify-content: space-between; padding: 1em; pointer-events: auto; z-index: 1000;">
            <div
                style="align-self: flex-start; font-size: 1.5em; background: white; padding: 0.5em; border-radius: 8px;">
                🪙
                <span id="shopCoinCount">0</span>
            </div>
            <div style="flex-grow: 1; display: flex; flex-direction: column; justify-content: center;">
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <img src="assets/cosm.arrow.png" data-type="cosmetic" data-img="assets/cosm.arrow.png" data-cost="5"
                        class="shop-item" style="width: 50px; height: 50px; margin-right: 10px; cursor: pointer;">
                    <span>5 coins</span>
                </div>
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <img src="assets/cosm.beret.treviv.png" data-type="cosmetic" data-img="assets/cosm.beret.treviv.png"
                        data-cost="5" class="shop-item"
                        style="width: 50px; height: 50px; margin-right: 10px; cursor: pointer;">
                    <span>5 coins</span>
                </div>
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <img src="assets/cosm.devil.treviv.png" data-type="cosmetic" data-img="assets/cosm.devil.treviv.png"
                        data-cost="10" class="shop-item"
                        style="width: 50px; height: 50px; margin-right: 10px; cursor: pointer;">
                    <span>10 coins</span>
                </div>
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <img src="assets/potion.a.treviv.png" data-type="potion" data-img="assets/potion.a.treviv.png"
                        data-cost="15" data-effect="speed" class="shop-item"
                        style="width: 50px; height: 50px; margin-right: 10px; cursor: pointer;">
                    <span>15 coins</span>
                </div>
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <img src="assets/potion.b.treviv.png" data-type="potion" data-img="assets/potion.b.treviv.png"
                        data-cost="20" data-effect="wallwalk" class="shop-item"
                        style="width: 50px; height: 50px; margin-right: 10px; cursor: pointer;">
                    <span>20 coins</span>
                </div>
                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                    <img src="assets/potion.c.treviv.png" data-type="potion" data-img="assets/potion.c.treviv.png"
                        data-cost="15" data-effect="doublecoins" class="shop-item"
                        style="width: 50px; height: 50px; margin-right: 10px; cursor: pointer;">
                    <span>15 coins</span>
                </div>
            </div>
            <button id="btnShopBack" type="button"
                style="pointer-events: auto; padding: 0.8em 2em; background: red; color: white; border: none; border-radius: 8px; font-size: 1.2em;">BACK</button>
        </div>
    </div>
    <div id="screen-complete">
        <h2>Level Complete!</h2>
        <div>🪙 <span id="totalCoins">0</span></div>
        <button id="btnNext">Next Level</button>
        <button id="btnEnd" class="red-btn">End Game</button>
    </div>
    <div id="screen-times">
        <h2>Completion Times</h2>
        <p id="averageTime"></p>
        <p id="fastestTime"></p>
        <p id="medalMessage" style="color:gold;font-weight:bold;"></p>
        <ul id="timeList"></ul>
        <button id="btnBackToMenu">Back</button>
    </div>


    <audio id="popSound"
        src="https://cdn.pixabay.com/download/audio/2022/02/23/audio_4d2d610b20.mp3?filename=button-124476.mp3"></audio>
    <audio id="coinSound"
        src="https://cdn.pixabay.com/download/audio/2021/08/04/audio_b2cb512a44.mp3?filename=coin-pick-up-199316.mp3"></audio>
    <audio id="dingSound" src="assets/ding.mp3"></audio>
    <audio id="finishedSound" src="assets/finished.mp3"></audio>

    <div id="controls" style="display: none;">
        <div></div>
        <div id="btnUp" class="control-btn"><img src="assets/up.arrow.treviv.png" alt="Up"
                style="width: 100%; height: 100%; object-fit: contain;" /></div>
        <div></div>
        <div id="btnLeft" class="control-btn"><img src="assets/left.arrow.png" alt="Left"
                style="width: 100%; height: 100%; object-fit: contain;" /></div>
        <div id="btnDown" class="control-btn"><img src="assets/down.arrow.png" alt="Down"
                style="width: 100%; height: 100%; object-fit: contain;" /></div>
        <div id="btnRight" class="control-btn"><img src="assets/right.arrow.treviv.png" alt="Right"
                style="width: 100%; height: 100%; object-fit: contain;" /></div>
    </div>

    <script>
        const gameTitle = document.getElementById("gameTitle");
        const screenStart = document.getElementById("screen-start");
        const screenName = document.getElementById("screen-name");
        const screenGame = document.getElementById("screen-game");
        const screenComplete = document.getElementById("screen-complete");
        const screenTimes = document.getElementById("screen-times");
        const btnStart1 = document.getElementById("btnStart1");
        const btnStart2 = document.getElementById("btnStart2");
        const btnNext = document.getElementById("btnNext");
        const btnEnd = document.getElementById("btnEnd");
        const btnShowTimes = document.getElementById("btnShowTimes");
        const nameInput = document.getElementById("nameInput");
        const totalCoinsDisplay = document.getElementById("totalCoins");
        const coinCountDisplay = document.getElementById("coinCount");
        const popSound = document.getElementById("popSound");
        const coinSound = document.getElementById("coinSound");
        const dingSound = document.getElementById("dingSound");
        const finishedSound = document.getElementById("finishedSound");
        const canvas = document.getElementById("mazeCanvas");
        const ctx = canvas.getContext("2d");
        const timeList = document.getElementById("timeList");
        const btnBackToMenu = document.getElementById("btnBackToMenu");
        btnBackToMenu.onclick = () => showScreen(screenStart);

        let playerName = "";
        let player = { x: 0, y: 0, size: 20, imageLoaded: false };
        // Potion effect control flags
        let speedMultiplier = 1;
        let wallWalkEnabled = false;
        let coinMultiplier = 1;
        // Shop variables
        let shop = null;
        const shopImage = new Image();
        shopImage.src = 'assets/shop.treviv.png';
        shopImage.onload = () => {
            shopImage.loaded = true;
        };
        // Load player image
        const playerImage = new Image();
        playerImage.src = 'assets/player.png';
        playerImage.onload = () => {
            player.imageLoaded = true;
        };
        // Load wall image
        const wallImage = new Image();
        wallImage.src = 'assets/bricks.png';
        wallImage.onload = () => {
            wallImage.loaded = true;
        };

        // Load floor tile image
        const floorImage = new Image();
        floorImage.src = 'assets/floortile.png';
        floorImage.onload = () => {
            floorImage.loaded = true;
        };

        // Load exit pad image
        const exitImage = new Image();
        exitImage.src = 'assets/win.png';
        exitImage.onload = () => {
            exitImage.loaded = true;
        };

        // Load animated coin frames
        const coinFrames = [];
        const COIN_FRAME_COUNT = 10;
        let coinFrameIndex = 0;
        let coinFrameTimer = performance.now();
        const COIN_FRAME_DURATION = 50; // ms per frame

        for (let i = 1; i <= COIN_FRAME_COUNT; i++) {
            const img = new Image();
            img.src = `assets/coin/coin-${i}.png`;
            coinFrames.push(img);
        }

        // Load clicktrap image
        const clickTrapImage = new Image();
        clickTrapImage.src = 'assets/clicktrap.png';
        clickTrapImage.onload = () => {
            clickTrapImage.loaded = true;
        };
        ctx.imageSmoothingEnabled = false;
        // Consistent scale for all tile images
        const TILE_SCALE = 1; // or adjust to 1.25, 1.5 etc. as needed
        const TILE_SIZE = 50;
        let camera = { x: 0, y: 0 };
        let walls = [];
        let coins = [];
        let exit = { x: 0, y: 0, size: 40 };
        let totalCoins = 0;
        let collectedThisLevel = 0;
        let times = [];
        let startTime = 0;
        // Blocks with number 20
        let blocks = [];

        function showScreen(screen) {
            [screenStart, screenName, screenGame, screenComplete, screenTimes].forEach(s => s.classList.remove("visible"));
            screen.classList.add("visible");

            const controls = document.getElementById("controls");
            if (screen === screenGame) {
                controls.style.display = "grid";
            } else {
                controls.style.display = "none";
                document.getElementById("shop-screen").classList.add("hidden");
            }
        }

        btnStart1.onclick = () => {
            popSound.play();
            showScreen(screenName);
        };

        btnStart2.onclick = () => {
            gameTitle.className = 'hidden';
            playerName = nameInput.value || "Player";
            totalCoins = parseInt(localStorage.getItem("totalCoins") || "0", 10);
            updateCoinDisplay();
            showScreen(screenGame);
            const shopScreen = document.getElementById("shop-screen");
            shopScreen.classList.add("hidden");
            shopScreen.style.display = "none";
            startLevel();
        };

        btnNext.onclick = () => {
            showScreen(screenGame);
            startLevel();
        };

        btnEnd.onclick = () => {
            location.reload();
        };

        btnShowTimes.onclick = () => {
            // Retrieve saved times
            times = JSON.parse(localStorage.getItem("savedTimes") || "[]");
            showScreen(screenTimes);
            if (times.length === 0) {
                timeList.innerHTML = '<li>No times recorded.</li>';
                document.getElementById('averageTime').textContent = '';
                document.getElementById('fastestTime').textContent = '';
                document.getElementById('medalMessage').textContent = '';
                return;
            }

            const average = times.reduce((a, b) => a + b, 0) / times.length;
            const minTime = Math.min(...times);
            const minIndex = times.indexOf(minTime);

            // Personal best logic (medal/award system)
            let bestCount = parseInt(localStorage.getItem("bestCount") || "0", 10);
            const previousBest = parseFloat(localStorage.getItem("bestTime") || "Infinity");

            if (minTime < previousBest) {
                bestCount++;
                localStorage.setItem("bestTime", minTime.toString());
                localStorage.setItem("bestCount", bestCount.toString());

                let medal = "🏅 New Personal Best! 🏅";
                if (bestCount === 1) medal = "🥉 Bronze Medal for First Personal Best!";
                else if (bestCount === 2) medal = "🥈 Silver Medal for Second Personal Best!";
                else if (bestCount === 3) medal = "🥇 Gold Medal for Third Personal Best!";
                document.getElementById("medalMessage").textContent = medal;
            } else {
                document.getElementById("medalMessage").textContent = "";
            }

            document.getElementById('averageTime').textContent =
                `Average Time: ${Math.floor(average / 60)}m ${(average % 60).toFixed(2)}s`;

            document.getElementById('fastestTime').textContent =
                `Fastest Time: Level ${minIndex + 1} - ${Math.floor(minTime / 60)}m ${(minTime % 60).toFixed(2)}s`;

            timeList.innerHTML = times.map((t, i) => {
                const minutes = Math.floor(Number(t) / 60);
                const seconds = (Number(t) % 60).toFixed(2).padStart(5, '0');
                const isFastest = i === minIndex;
                return `<li${isFastest ? ' style="font-weight:bold;color:green;"' : ''}>Level ${i + 1}: ${minutes}m ${seconds}s</li>`;
            }).join('');
        };

        function startLevel() {
            // Generate maze first so exit is placed
            generateMaze();

            // Set canvas to fill the screen
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // Find the furthest spawn location from the exit
            let furthestDistance = -1;
            let spawnX = 0;
            let spawnY = 0;
            for (let row = 0; row < 40; row++) {
                for (let col = 0; col < 40; col++) {
                    const x = col * 50;
                    const y = row * 50;
                    if (!collidesWall(x + 5, y + 5)) {
                        const dx = (x - exit.x);
                        const dy = (y - exit.y);
                        const distance = dx * dx + dy * dy;
                        if (distance > furthestDistance) {
                            furthestDistance = distance;
                            spawnX = x + 5;
                            spawnY = y + 5;
                        }
                    }
                }
            }
            player.x = spawnX;
            player.y = spawnY;
            camera.x = 0;
            camera.y = 0;
            collectedThisLevel = 0;
            updateCoinDisplay();
            requestAnimationFrame(() => {
                startTime = performance.now();
                gameLoop();
            });
        }

        function updateCoinDisplay() {
            coinCountDisplay.textContent = `🪙 ${totalCoins}`;
            localStorage.setItem("totalCoins", totalCoins);
        }

        function generateMaze() {
            walls = [];
            coins = [];
            const mazeCols = 40;
            const mazeRows = 40;
            // const cellSize = 10;
            const cellSize = 50;

            // Initialize grid with walls
            let grid = Array.from({ length: mazeRows }, () => Array(mazeCols).fill(1));

            // Start at top-left corner
            let x = 1, y = 1;
            grid[y][x] = 0;

            // Carve a path to a random bottom-right area
            while (x < mazeCols - 2 || y < mazeRows - 2) {
                if ((Math.random() < 0.5 && x < mazeCols - 2) || y >= mazeRows - 2) x++;
                else if (y < mazeRows - 2) y++;
                grid[y][x] = 0;
            }

            exit.x = x * cellSize;
            exit.y = y * cellSize;

            // Add random dead ends
            for (let row = 1; row < mazeRows - 1; row++) {
                for (let col = 1; col < mazeCols - 1; col++) {
                    if (grid[row][col] === 1 && Math.random() < 0.4) {
                        grid[row][col] = 0;
                    }
                }
            }

            // Create wall objects
            const mazeSize = mazeCols * cellSize;
            // const borderThickness = 8;
            const borderThickness = 40;
            walls.push(
                { x: 0, y: 0, w: mazeSize, h: borderThickness },
                { x: 0, y: mazeSize - borderThickness, w: mazeSize, h: borderThickness },
                { x: 0, y: 0, w: borderThickness, h: mazeSize },
                { x: mazeSize - borderThickness, y: 0, w: borderThickness, h: mazeSize }
            );

            for (let row = 0; row < mazeRows; row++) {
                for (let col = 0; col < mazeCols; col++) {
                    if (grid[row][col] === 1) {
                        walls.push({ x: col * cellSize, y: row * cellSize, w: cellSize, h: cellSize });
                    } else if (Math.random() < 0.05) {
                        coins.push({ x: col * cellSize + cellSize / 2, y: row * cellSize + cellSize / 2, r: 15 });
                    }
                }
            }

            // Add block with number 20 on it at a few places
            blocks = [];
            for (let i = 0; i < 3; i++) {
                let placed = false;
                while (!placed) {
                    const col = Math.floor(Math.random() * mazeCols);
                    const row = Math.floor(Math.random() * mazeRows);
                    if (grid[row][col] === 0) {
                        blocks.push({ x: col * cellSize, y: row * cellSize, clicks: 0 });
                        placed = true;
                    }
                }
            }

            // Place shop only if current level is 5 (times.length === 4)
            if (times.length === 4) {
                let placed = false;
                const maxSpawnCol = Math.min(5, mazeCols - 2);
                const maxSpawnRow = Math.min(5, mazeRows - 2);
                while (!placed) {
                    const col = Math.floor(Math.random() * maxSpawnCol);
                    const row = Math.floor(Math.random() * maxSpawnRow);
                    if (
                        grid[row][col] === 0 &&
                        grid[row][col + 1] === 0 &&
                        grid[row + 1][col] === 0 &&
                        grid[row + 1][col + 1] === 0
                    ) {
                        shop = { x: col * cellSize, y: row * cellSize, size: cellSize * 2 };
                        placed = true;
                    }
                }
            } else {
                shop = null;
            }
        }

        let keys = {};
        window.addEventListener("keydown", e => keys[e.key] = true);
        window.addEventListener("keyup", e => keys[e.key] = false);

        const btnUp = document.getElementById("btnUp");
        const btnDown = document.getElementById("btnDown");
        const btnLeft = document.getElementById("btnLeft");
        const btnRight = document.getElementById("btnRight");

        btnUp?.addEventListener("touchstart", () => keys.ArrowUp = true);
        btnUp?.addEventListener("touchend", () => keys.ArrowUp = false);
        btnDown?.addEventListener("touchstart", () => keys.ArrowDown = true);
        btnDown?.addEventListener("touchend", () => keys.ArrowDown = false);
        btnLeft?.addEventListener("touchstart", () => keys.ArrowLeft = true);
        btnLeft?.addEventListener("touchend", () => keys.ArrowLeft = false);
        btnRight?.addEventListener("touchstart", () => keys.ArrowRight = true);
        btnRight?.addEventListener("touchend", () => keys.ArrowRight = false);

        // Add mouse support for arrow buttons
        btnUp?.addEventListener("mousedown", () => keys.ArrowUp = true);
        btnUp?.addEventListener("mouseup", () => keys.ArrowUp = false);
        btnDown?.addEventListener("mousedown", () => keys.ArrowDown = true);
        btnDown?.addEventListener("mouseup", () => keys.ArrowDown = false);
        btnLeft?.addEventListener("mousedown", () => keys.ArrowLeft = true);
        btnLeft?.addEventListener("mouseup", () => keys.ArrowLeft = false);
        btnRight?.addEventListener("mousedown", () => keys.ArrowRight = true);
        btnRight?.addEventListener("mouseup", () => keys.ArrowRight = false);

        function collidesWall(newX, newY) {
            return walls.some(w =>
                newX < w.x + w.w &&
                newX + player.size > w.x &&
                newY < w.y + w.h &&
                newY + player.size > w.y
            );
        }

        function touchesMazeEdge(x, y) {
            const mazeLimit = 2000;
            const margin = 5;
            return (
                x < margin ||
                y < margin ||
                x + player.size > mazeLimit - margin ||
                y + player.size > mazeLimit - margin
            );
        }

        function gameLoop() {
            let newX = player.x;
            let newY = player.y;
            // Block movement only if player is on an uncleared block
            let onUnclearedBlock = false;
            for (const b of blocks) {
                if (
                    b.clicks < 20 &&
                    player.x + player.size > b.x &&
                    player.x < b.x + 50 &&
                    player.y + player.size > b.y &&
                    player.y < b.y + 50
                ) {
                    onUnclearedBlock = true;
                    break;
                }
            }

            if (onUnclearedBlock && (keys.ArrowUp || keys.ArrowDown || keys.ArrowLeft || keys.ArrowRight)) {
                newX = player.x;
                newY = player.y;
            } else {
                const moveSpeed = 3 * speedMultiplier;
                if (keys.ArrowUp) newY -= moveSpeed;
                if (keys.ArrowDown) newY += moveSpeed;
                if (keys.ArrowLeft) newX -= moveSpeed;
                if (keys.ArrowRight) newX += moveSpeed;
            }
            if ((!collidesWall(newX, newY) || wallWalkEnabled) && !touchesMazeEdge(newX, newY)) {
                player.x = newX;
                player.y = newY;
            }

            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;

            // Coin animation update
            if (performance.now() - coinFrameTimer > COIN_FRAME_DURATION) {
                coinFrameIndex = (coinFrameIndex + 1) % COIN_FRAME_COUNT;
                coinFrameTimer = performance.now();
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Fill area outside the maze with brick background
            if (wallImage.loaded) {
                for (let x = -TILE_SIZE; x < canvas.width + TILE_SIZE; x += TILE_SIZE) {
                    for (let y = -TILE_SIZE; y < canvas.height + TILE_SIZE; y += TILE_SIZE) {
                        const worldX = Math.floor((x + camera.x) / TILE_SIZE) * TILE_SIZE;
                        const worldY = Math.floor((y + camera.y) / TILE_SIZE) * TILE_SIZE;

                        // Only draw bricks where there is no floor tile
                        if (worldX < 0 || worldY < 0 || worldX >= 2000 || worldY >= 2000) {
                            ctx.drawImage(wallImage, x, y, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }
            }

            // Draw tiled floor snapped to grid
            if (floorImage.loaded) {
                for (let x = -TILE_SIZE; x < canvas.width + TILE_SIZE; x += TILE_SIZE) {
                    for (let y = -TILE_SIZE; y < canvas.height + TILE_SIZE; y += TILE_SIZE) {
                        const drawX = x - (camera.x % TILE_SIZE);
                        const drawY = y - (camera.y % TILE_SIZE);
                        ctx.drawImage(floorImage, drawX, drawY, TILE_SIZE, TILE_SIZE);
                    }
                }
            }

            // Draw walls using wallImage tiles if loaded, otherwise fallback to color
            if (wallImage.loaded) {
                walls.forEach(w => {
                    for (let dx = 0; dx < w.w; dx += TILE_SIZE) {
                        for (let dy = 0; dy < w.h; dy += TILE_SIZE) {
                            const aspect = wallImage.naturalWidth / wallImage.naturalHeight;
                            let drawW = TILE_SIZE;
                            let drawH = TILE_SIZE;

                            if (aspect > 1) {
                                drawH = TILE_SIZE / aspect;
                            } else {
                                drawW = TILE_SIZE * aspect;
                            }

                            ctx.drawImage(
                                wallImage,
                                w.x + dx - camera.x + (TILE_SIZE - drawW) / 2,
                                w.y + dy - camera.y + (TILE_SIZE - drawH) / 2,
                                drawW,
                                drawH
                            );
                        }
                    }
                });
            } else {
                ctx.fillStyle = "darkred";
                walls.forEach(w => ctx.fillRect(w.x - camera.x, w.y - camera.y, w.w, w.h));
            }

            coins = coins.filter(c => {
                const dx = player.x - c.x;
                const dy = player.y - c.y;
                if (Math.hypot(dx, dy) < player.size) {
                    coinSound.play();
                    dingSound.play();
                    totalCoins += coinMultiplier;
                    collectedThisLevel += coinMultiplier;
                    updateCoinDisplay();
                    return false;
                }
                // Draw animated coin frame if loaded, else fallback to yellow circle
                const frame = coinFrames[coinFrameIndex];
                if (frame?.complete && frame.naturalWidth > 0) {
                    ctx.drawImage(
                        frame,
                        c.x - TILE_SIZE / 2 - camera.x,
                        c.y - TILE_SIZE / 2 - camera.y,
                        TILE_SIZE,
                        TILE_SIZE
                    );
                } else {
                    ctx.fillStyle = "yellow";
                    ctx.beginPath();
                    ctx.arc(c.x - camera.x, c.y - camera.y, c.r, 0, 2 * Math.PI);
                    ctx.fill();
                }
                return true;
            });

            // Draw blocks
            blocks.forEach(b => {
                if (b.clicks < 20) {
                    if (clickTrapImage.loaded) {
                        ctx.drawImage(
                            clickTrapImage,
                            b.x - camera.x,
                            b.y - camera.y,
                            TILE_SIZE,
                            TILE_SIZE
                        );
                        ctx.strokeStyle = "yellow";
                        ctx.lineWidth = 3;
                        ctx.strokeRect(
                            b.x - camera.x,
                            b.y - camera.y,
                            TILE_SIZE,
                            TILE_SIZE
                        );
                        ctx.fillStyle = "black";
                        ctx.font = "20px sans-serif";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(
                            `${20 - b.clicks}`,
                            b.x - camera.x + TILE_SIZE / 2,
                            b.y - camera.y + TILE_SIZE / 2
                        );
                    } else {
                        ctx.fillStyle = "white";
                        ctx.fillRect(b.x - camera.x, b.y - camera.y, 50, 50);
                        ctx.strokeStyle = "yellow";
                        ctx.lineWidth = 3;
                        ctx.strokeRect(b.x - camera.x, b.y - camera.y, 50, 50);
                        ctx.fillStyle = "black";
                        ctx.font = "20px sans-serif";
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                        ctx.fillText(
                            `${20 - b.clicks}`,
                            b.x - camera.x + TILE_SIZE / 2,
                            b.y - camera.y + TILE_SIZE / 2
                        );
                    }
                }
            });

            const glowSize = 20;
            const exitCenterX = exit.x + exit.size / 2 - camera.x;
            const exitCenterY = exit.y + exit.size / 2 - camera.y;

            // Draw glow
            const gradient = ctx.createRadialGradient(exitCenterX, exitCenterY, 10, exitCenterX, exitCenterY, glowSize);
            gradient.addColorStop(0, 'rgba(0,255,0,0.7)');
            gradient.addColorStop(1, 'rgba(0,255,0,0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(exitCenterX, exitCenterY, glowSize, 0, Math.PI * 2);
            ctx.fill();

            // Draw actual exit
            if (exitImage.loaded) {
                const drawW = TILE_SIZE;
                const drawH = TILE_SIZE;
                ctx.drawImage(
                    exitImage,
                    exit.x - camera.x + (TILE_SIZE - drawW) / 2,
                    exit.y - camera.y + (TILE_SIZE - drawH) / 2,
                    drawW,
                    drawH
                );
            } else {
                ctx.fillStyle = "green";
                ctx.fillRect(exit.x - camera.x, exit.y - camera.y, TILE_SIZE, TILE_SIZE);
            }

            if (player.imageLoaded) {
                ctx.drawImage(
                    playerImage,
                    player.x - camera.x - player.size / 2,
                    player.y - camera.y - player.size / 2,
                    player.size * 2,
                    player.size * 2
                );
            }

            // Draw shop if present and loaded
            if (shop && shopImage.loaded) {
                ctx.drawImage(
                    shopImage,
                    shop.x - camera.x,
                    shop.y - camera.y,
                    shop.size,
                    shop.size
                );
            }

            ctx.fillStyle = "black";
            ctx.font = "16px sans-serif";
            ctx.fillText(playerName, player.x - camera.x - 20, player.y - camera.y - 10);

            if (
                player.x > exit.x && player.x < exit.x + exit.size &&
                player.y > exit.y && player.y < exit.y + exit.size
            ) {
                const elapsed = (performance.now() - startTime) / 1000;
                times.push(elapsed);
                localStorage.setItem("savedTimes", JSON.stringify(times));
                totalCoinsDisplay.textContent = totalCoins;
                finishedSound.play();
                showScreen(screenComplete);
                return;
            }

            requestAnimationFrame(gameLoop);
        }
        // Canvas click event to detect clicks on blocks
        canvas.addEventListener("click", function (e) {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left + camera.x;
            const clickY = e.clientY - rect.top + camera.y;

            for (let b of blocks) {
                if (
                    b.clicks < 20 &&
                    clickX >= b.x &&
                    clickX <= b.x + 50 &&
                    clickY >= b.y &&
                    clickY <= b.y + 50
                ) {
                    b.clicks++;
                    break;
                }
            }
        });

        // Handle shop click
        canvas.addEventListener("click", function (e) {
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left + camera.x;
            const clickY = e.clientY - rect.top + camera.y;

            if (shop && shopImage.loaded) {
                const withinShop =
                    clickX >= shop.x &&
                    clickX <= shop.x + shop.size &&
                    clickY >= shop.y &&
                    clickY <= shop.y + shop.size;

                const nearPlayer =
                    Math.abs(player.x - shop.x) < 100 &&
                    Math.abs(player.y - shop.y) < 100;

                if (withinShop && nearPlayer) {
                    const shopScreen = document.getElementById("shop-screen");
                    shopScreen.classList.remove("hidden");
                    shopScreen.style.display = "flex";
                    document.getElementById("shopCoinCount").textContent = totalCoins;
                }
            }
        });

        // Handle shop BACK button
        document.getElementById("btnShopBack").onclick = () => {
            const shopScreen = document.getElementById("shop-screen");
            shopScreen.classList.add("hidden");
            shopScreen.style.display = "none";
        };
        // Shop item purchase logic
        document.querySelectorAll('.shop-item').forEach(item => {
            item.addEventListener('click', () => {
                if (item.classList.contains('sold')) return;

                const cost = parseInt(item.dataset.cost, 10);
                if (totalCoins < cost) return;

                totalCoins -= cost;
                updateCoinDisplay();
                document.getElementById("shopCoinCount").textContent = totalCoins;
                item.classList.add('sold');

                const outOfStock = document.createElement('span');
                outOfStock.textContent = 'OUT OF STOCK';
                outOfStock.style.color = 'red';
                outOfStock.style.marginLeft = '10px';
                item.parentNode.appendChild(outOfStock);

                const type = item.dataset.type;
                const imgSrc = item.dataset.img;

                if (type === 'cosmetic') {
                    playerImage.src = imgSrc;
                } else if (type === 'potion') {
                    const potionDisplay = document.createElement('img');
                    potionDisplay.src = imgSrc;
                    potionDisplay.style.width = '40px';
                    potionDisplay.style.height = '40px';
                    potionDisplay.style.position = 'absolute';
                    potionDisplay.style.bottom = '10px';
                    potionDisplay.style.left = `${10 + document.querySelectorAll('.potion-icon').length * 50}px`;
                    potionDisplay.style.border = '2px solid black';
                    potionDisplay.className = 'potion-icon';
                    document.body.appendChild(potionDisplay);
                }
            });
        });

        // Potion activation logic
        document.body.addEventListener('click', function (e) {
            const potion = e.target;
            if (!potion.classList.contains('potion-icon')) return;

            const effect = Array.from(document.querySelectorAll('.shop-item'))
                .find(item => item.dataset.img === potion.src)?.dataset.effect;
            if (!effect) return;

            potion.remove();

            if (effect === 'speed') {
                speedMultiplier = 2;
                setTimeout(() => speedMultiplier = 1, 5000);
            } else if (effect === 'wallwalk') {
                wallWalkEnabled = true;
                setTimeout(() => wallWalkEnabled = false, 5000);
            } else if (effect === 'doublecoins') {
                coinMultiplier = 2;
                setTimeout(() => coinMultiplier = 1, 10000);
            }
        });
    </script>
</body>

</html>